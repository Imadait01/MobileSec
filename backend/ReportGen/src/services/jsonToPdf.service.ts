import fs from 'fs';
import fsPromises from 'fs/promises';
import path from 'path';
import PDFDocument from 'pdfkit';
import logger from '../utils/logger';

export class JsonToPdfService {
  async convert(jsonPath: string, outputPdfPath?: string): Promise<string> {
    const jsonContent = await fsPromises.readFile(jsonPath, 'utf-8');
    let data: any;
    try {
      data = JSON.parse(jsonContent);
    } catch (e) {
      logger.error('Invalid JSON file for conversion to PDF', { error: String(e), jsonPath });
      throw e;
    }

    const outPdf = outputPdfPath || jsonPath.replace(/\.json$/i, '.pdf');

    // Ensure directory exists
    await fsPromises.mkdir(path.dirname(outPdf), { recursive: true });

    return new Promise<string>((resolve, reject) => {
      try {
        const doc = new PDFDocument({ size: 'A4', margin: 40 });
        const stream = fs.createWriteStream(outPdf);
        doc.pipe(stream);

        // Header
        doc.fontSize(18).text(data.projectName || 'Security Report', { align: 'center' });
        doc.moveDown(0.5);
        doc.fontSize(10).fillColor('#666').text(`Generated: ${data.generatedAt || new Date().toISOString()}`, { align: 'center' });
        doc.moveDown(1);

        // Summary / Metrics
        if (data.metrics) {
          doc.fontSize(12).fillColor('#000').text('Summary', { underline: true });
          doc.moveDown(0.3);
          const metrics = data.metrics;
          doc.fontSize(10).fillColor('#000');
          doc.text(`Total vulnerabilities: ${metrics.total || 0}`);
          doc.text(`Security Score: ${metrics.securityScore ?? metrics.security_score ?? 'N/A'}`);
          doc.moveDown(0.6);
        }

        // Priority recommendations
        if (data.priorityRecommendations && Array.isArray(data.priorityRecommendations)) {
          doc.fontSize(12).text('Priority Recommendations', { underline: true });
          doc.moveDown(0.3);
          data.priorityRecommendations.slice(0, 10).forEach((r: string, idx: number) => {
            doc.fontSize(10).text(`${idx + 1}. ${r}`);
          });
          doc.moveDown(0.6);
        }

        // Vulnerabilities (first 300 to avoid huge PDF)
        const vulns = Array.isArray(data.vulnerabilities) ? data.vulnerabilities : (data.vulnerabilities || []);
        if (vulns.length > 0) {
          doc.fontSize(12).text('Vulnerabilities (sample)', { underline: true });
          doc.moveDown(0.3);

          const limit = Math.min(vulns.length, 300);
          for (let i = 0; i < limit; i++) {
            const v = vulns[i];
            doc.fontSize(10).fillColor('#000').text(`${i + 1}. ${v.title || v.vulnerability || v.type || 'Vulnerability'}`);
            if (v.file) doc.fontSize(9).fillColor('#444').text(`  File: ${v.file}`);
            if (v.line) doc.fontSize(9).fillColor('#444').text(`  Line: ${v.line}`);
            if (v.recommendation) doc.fontSize(9).fillColor('#000').text(`  Recommendation: ${v.recommendation}`);
            doc.moveDown(0.2);
          }

          if (vulns.length > limit) {
            doc.fontSize(10).fillColor('#666').text(`...and ${vulns.length - limit} more findings omitted.`);
          }
        }

        // Footer
        doc.moveDown(1);
        doc.fontSize(9).fillColor('#666').text('Generated by ReportGen', { align: 'right' });

        doc.end();

        stream.on('finish', () => {
          logger.info('JSON -> PDF conversion completed', { outPdf });
          resolve(outPdf);
        });

        stream.on('error', (err) => reject(err));
      } catch (err) {
        reject(err);
      }
    });
  }
}

export const jsonToPdfService = new JsonToPdfService();